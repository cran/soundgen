% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/formants.R
\name{addFormants}
\alias{addFormants}
\title{Add formants}
\usage{
addFormants(
  x,
  samplingRate = NULL,
  formants,
  spectralEnvelope = NULL,
  zFun = NULL,
  action = c("add", "remove")[1],
  vocalTract = NA,
  formantDep = 1,
  formantDepStoch = 1,
  formantWidth = 1,
  formantCeiling = 2,
  lipRad = 6,
  noseRad = 4,
  mouthOpenThres = 0,
  mouth = NA,
  interpol = c("approx", "spline", "loess")[3],
  temperature = 0.025,
  formDrift = 0.3,
  formDisp = 0.2,
  windowLength_points = 800,
  overlap = 75,
  normalize = TRUE,
  play = FALSE,
  saveAudio = NULL,
  reportEvery = NULL,
  ...
)
}
\arguments{
\item{x}{path to a folder, one or more wav or mp3 files c('file1.wav',
'file2.mp3'), Wave object, numeric vector, or a list of Wave objects or
numeric vectors}

\item{samplingRate}{sampling frequency, Hz}

\item{formants}{either a character string like "aaui" referring to default
presets for speaker "M1" or a list of formant times, frequencies,
amplitudes, and bandwidths (see ex. below). \code{formants = NA} defaults
to schwa. Time stamps for formants and mouthOpening can be specified in ms
or an any other arbitrary scale. See \code{\link{getSpectralEnvelope}} for
more details}

\item{spectralEnvelope}{(optional): as an alternative to specifying formant
frequencies, we can provide the exact filter - a vector of non-negative
numbers specifying the power in each frequency bin on a linear scale
(interpolated to length equal to windowLength_points/2). A matrix
specifying the filter for each STFT step is also accepted. The easiest way
to create this matrix is to call soundgen:::getSpectralEnvelope or to use
the spectrum of a recorded sound}

\item{zFun}{(optional) an arbitrary function to apply to the spectrogram
prior to iSTFT, where "z" is the spectrogram - a matrix of complex values
(see examples)}

\item{action}{'add' = add formants to the sound, 'remove' = remove formants
(inverse filtering)}

\item{vocalTract}{the length of vocal tract, cm. Used for calculating formant
dispersion (for adding extra formants) and formant transitions as the mouth
opens and closes. If \code{NULL} or \code{NA}, the length is estimated
based on specified formant frequencies, if any (anchor format)}

\item{formantDep}{scale factor of formant amplitude (1 = no change relative
to amplitudes in \code{formants})}

\item{formantDepStoch}{the amplitude of additional stochastic formants added
above the highest specified formant, dB (only if temperature > 0)}

\item{formantWidth}{scale factor of formant bandwidth (1 = no change)}

\item{formantCeiling}{frequency to which stochastic formants are calculated,
in multiples of the Nyquist frequency; increase up to ~10 for long vocal
tracts to avoid losing energy in the upper part of the spectrum}

\item{lipRad}{the effect of lip radiation on source spectrum, dB/oct (the
default of +6 dB/oct produces a high-frequency boost when the mouth is
open)}

\item{noseRad}{the effect of radiation through the nose on source spectrum,
dB/oct (the alternative to \code{lipRad} when the mouth is closed)}

\item{mouthOpenThres}{open the lips (switch from nose radiation to lip
radiation) when the mouth is open \code{>mouthOpenThres}, 0 to 1}

\item{mouth}{mouth opening (0 to 1, 0.5 = neutral, i.e. no
modification) (anchor format)}

\item{interpol}{the method of smoothing envelopes based on provided mouth
anchors: 'approx' = linear interpolation, 'spline' = cubic spline, 'loess'
(default) = polynomial local smoothing function. NB: this does NOT affect
the smoothing of formant anchors}

\item{temperature}{hyperparameter for regulating the amount of stochasticity
in sound generation}

\item{formDrift, formDisp}{scaling factors for the effect of temperature on
formant drift and dispersal, respectively}

\item{windowLength_points}{length of FFT window, points}

\item{overlap}{FFT window overlap, \%. For allowed values, see
\code{\link[seewave]{istft}}}

\item{normalize}{if TRUE, normalizes the output to range from -1 to +1}

\item{play}{if TRUE, plays the synthesized sound using the default player on
your system. If character, passed to \code{\link[tuneR]{play}} as the name
of player to use, eg "aplay", "play", "vlc", etc. In case of errors, try
setting another default player for \code{\link[tuneR]{play}}}

\item{saveAudio}{path + filename for saving the output, e.g.
'~/Downloads/temp.wav'. If NULL = doesn't save}

\item{reportEvery}{when processing multiple inputs, report estimated time
left every ... iterations (NULL = default, NA = don't report)}

\item{...}{other plotting parameters passed to \code{\link{spectrogram}}}
}
\description{
A spectral filter that either adds or removes formants from a sound - that
is, amplifies or dampens certain frequency bands, as in human vowels. See
\code{\link{soundgen}} and \code{\link{getSpectralEnvelope}} for more
information. With \code{action = 'remove'} this function can perform inverse
filtering to remove formants and obtain raw glottal output, provided that you
can specify the correct formant structure. Instead of formants, any arbitrary
spectral filtering function can be applied using the \code{spectralEnvelope}
argument (eg for a low/high/bandpass filter).
}
\details{
Algorithm: converts input from a time series (time domain) to a spectrogram
(frequency domain) through short-term Fourier transform (STFT), multiples by
the spectral filter containing the specified formants, and transforms back to
a time series via inverse STFT. This is a subroutine for voice synthesis in
\code{\link{soundgen}}, but it can also be applied to a recording.
}
\examples{
sound = c(rep(0, 1000), runif(8000) * 2 - 1, rep(0, 1000))  # white noise
# NB: pad with silence to avoid artefacts if removing formants
# playme(sound)
# spectrogram(sound, samplingRate = 16000)

# add F1 = 900, F2 = 1300 Hz
sound_filtered = addFormants(sound, samplingRate = 16000,
                             formants = c(900, 1300))
# playme(sound_filtered)
# spectrogram(sound_filtered, samplingRate = 16000)

# ...and remove them again (assuming we know what the formants are)
sound_inverse_filt = addFormants(sound_filtered,
                                 samplingRate = 16000,
                                 formants = c(900, 1300),
                                 action = 'remove')
# playme(sound_inverse_filt)
# spectrogram(sound_inverse_filt, samplingRate = 16000)

\dontrun{
## Perform some user-defined manipulation of the spectrogram with zFun
# Ex.: noise removal - silence all bins under threshold,
# say -0 dB below the max value
s_noisy = soundgen(sylLen = 200, addSilence = 0,
                   noise = list(time = c(-100, 300), value = -20))
spectrogram(s_noisy, 16000)
# playme(s_noisy)
zFun = function(z, cutoff = -50) {
  az = abs(z)
  thres = max(az) * 10 ^ (cutoff / 20)
  z[which(az < thres)] = 0
  return(z)
}
s_denoised = addFormants(s_noisy, samplingRate = 16000,
                         formants = NA, zFun = zFun, cutoff = -40)
spectrogram(s_denoised, 16000)
# playme(s_denoised)

## Use the spectral envelope of an existing recording (bleating of a sheep)
# (see also the same example with noise as source in ?generateNoise)
# (NB: this can also be achieved with a single call to transplantFormants)
data(sheep, package = 'seewave')  # import a recording from seewave
sound_orig = as.numeric(scale(sheep@left))
samplingRate = sheep@samp.rate
sound_orig = sound_orig / max(abs(sound_orig))  # range -1 to +1
# playme(sound_orig, samplingRate)

# get a few pitch anchors to reproduce the original intonation
pitch = analyze(sound_orig, samplingRate = samplingRate,
  pitchMethod = c('autocor', 'dom'))$detailed$pitch
pitch = pitch[!is.na(pitch)]

# extract a frequency-smoothed version of the original spectrogram
# to use as filter
specEnv_bleating = spectrogram(sound_orig, windowLength = 5,
 samplingRate = samplingRate, output = 'original', plot = FALSE)
# image(t(log(specEnv_bleating)))

# Synthesize source only, with flat spectrum
sound_unfilt = soundgen(sylLen = 2500, pitch = pitch,
  rolloff = 0, rolloffOct = 0, rolloffKHz = 0,
  temperature = 0, jitterDep = 0, subDep = 0,
  formants = NULL, lipRad = 0, samplingRate = samplingRate,
  invalidArgAction = 'ignore')  # prevent soundgen from increasing samplingRate
# playme(sound_unfilt, samplingRate)
# seewave::meanspec(sound_unfilt, f = samplingRate, dB = 'max0')  # ~flat

# Force spectral envelope to the shape of target
sound_filt = addFormants(sound_unfilt, formants = NULL,
  spectralEnvelope = specEnv_bleating, samplingRate = samplingRate)
# playme(sound_filt, samplingRate)  # playme(sound_orig, samplingRate)
# spectrogram(sound_filt, samplingRate)  # spectrogram(sound_orig, samplingRate)

# The spectral envelope is now similar to the original recording. Compare:
par(mfrow = c(1, 2))
seewave::meanspec(sound_orig, f = samplingRate, dB = 'max0', alim = c(-50, 20))
seewave::meanspec(sound_filt, f = samplingRate, dB = 'max0', alim = c(-50, 20))
par(mfrow = c(1, 1))
# NB: but the source of excitation in the original is actually a mix of
# harmonics and noise, while the new sound is purely tonal
}
}
\seealso{
\code{\link{getSpectralEnvelope}} \code{\link{transplantFormants}}
  \code{\link{soundgen}}
}
